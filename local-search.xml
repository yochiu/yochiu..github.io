<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AOF</title>
    <link href="/2022/03/22/AOF/"/>
    <url>/2022/03/22/AOF/</url>
    
    <content type="html"><![CDATA[<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><blockquote><ul><li>数据库的写前日志（Write Ahead Log, WAL),   是先把修改的数据记到日志文件中，以便故障时进行恢复。不过，AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志</li></ul></blockquote><h4 id="AOF记录的内容"><a href="#AOF记录的内容" class="headerlink" title="AOF记录的内容"></a>AOF记录的内容</h4><blockquote><ul><li>数据库的redo log(重做日志),  记录的是修改后的数据.   AOF记录的是数据的执行命令</li><li>AOF日志内容有三个部分,   每部分都是由”$”+数字开头,  后面紧跟着具体的命令、键或值.</li><li>如下图所示,  这个 “*3”表示当前命令有三个部分，这里$表示有多少个字节</li></ul></blockquote><img src="../AOF/0.webp" width="55%" height="55%" /><h4 id="AOF三种策略"><a href="#AOF三种策略" class="headerlink" title="AOF三种策略"></a>AOF三种策略</h4><p>AOF一共有三种策略,  分别是no,  every sec,  always三种策略.</p><ul><li>No 操作系统控制的写回.  每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，  由操作系统决定何时将缓冲区内容写回磁盘。</li><li>Everysec  每秒写回,  每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</li><li>Always  同步写回：每个写命令执行完，立马同步地将日志写回磁盘</li></ul><img src="../AOF/1.webp" width="55%" height="55%" /><p>日志写到内存缓冲区对应的是write操作,  日志写回到磁盘对应的是fsync<br>fsync 需要把日志记录写回到磁盘后才能返回，时间较长<br>write操作只需要写内容到缓冲区,   就可以返回</p><p>Always 是同步写回,  需要确保日志写回到磁盘.  这个策略会阻塞主线程<br>Everysec 是每隔一秒将日志写入磁盘,   这个操作可以异步执行<br>No 写回策略.  是由操作系统决定将缓冲区内容写回磁盘,   这个操作也可以异步执行.</p><img src="../AOF/2.webp" width="55%" height="55%" /><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>随着命令执行次数的增加,  AOF日志文件会越来越大.<br>AOF日志是命令追加,   可以对AOF命令内容进行精简.  减少AOF日志大小</p><p>AOF是由后台子进程执行操作.<br>主线程仍然将命令写入到AOF文件内容缓冲区,<br>后台子进程会对原来的AOF文件进行数据拷贝,   同时也会将命令写入到AOF重写文件的内容缓冲区.<br>等后台子进程操作完成,   重写日志记录的这些最新操作也会写入新的 AOF 文件<br>此时,   就可以用新的AOF文件代替旧的AOF文件</p><p>后台子进程采用写实复制的功能.  写实复制值的是子进程跟主进程指向相同的内存地址空间,<br>只有当用户对key进行修改时,   主进程就会拷贝这个key对应的内存数据出来,  申请新的内存空间,   然后在上面进行数据修改,  这样就不会影响到原来的数据<br>写实复制:  fork子进程一瞬间是会阻塞主线程的,   文件重写过程中,   用户的对key值修改的越多,  需要申请内存空间,   申请内存空间越长,   也会产生阻塞风险. </p><img src="../AOF/3.webp" width="55%" height="55%" />]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis单线程阻塞点</title>
    <link href="/2022/03/21/Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%82%B9/"/>
    <url>/2022/03/21/Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis单线程阻塞点"><a href="#Redis单线程阻塞点" class="headerlink" title="Redis单线程阻塞点"></a>Redis单线程阻塞点</h1><ul><li>集合的全量查询以及聚合查询.  比如, 复杂度高O(n)的命令查询,  集合的交, 并, 差操作. </li><li>元素的删除操作.  删除的本质是要释放内存空间,   操作系统在释放内存空间时,  需要把释放的内存空间放回一个空闲内存快的链表.  这个操作,  会阻塞应用程序.  对于大key的删除,   需要特别注意</li><li>磁盘的交互操作.   比如AOF日志同步写.    取决于AOF的写回策略.  Always,   同步写回: 每个写命令执行完，立马同步地将日志写回磁盘.  这个写回策略会影响Redis主线程</li><li>RDB文件的加载.   RDB文件的传输跟接受是使用子进程.  但是从库在接受到RDB后,  需要使用FLUSHDB操作.  FLUSHDB操作会阻塞线程</li><li>切片集群的交互.  对于redis cluster集群来说,  切片间哈希槽信息需要在不同切片进行信息交互.  当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移</li></ul><h3 id="redis懒删除"><a href="#redis懒删除" class="headerlink" title="redis懒删除"></a>redis懒删除</h3><ul><li>lazy-free是4.0新增的功能，但是默认是关闭的，需要手动开启<blockquote><ul><li>手动开启lazy-free时，有4个选项可以控制，分别对应不同场景下，要不要开启异步释放内存机制：</li><li>lazyfree-lazy-expire：key在过期删除时尝试异步释放内存</li><li>lazyfree-lazy-eviction：内存达到maxmemory并设置了淘汰策略时尝试异步释放内存</li><li>lazyfree-lazy-server-del：执行RENAME&#x2F;MOVE等命令或需要覆盖一个key时，删除旧key尝试异步释放内存</li><li>replica-lazy-flush：主从全量同步，从库清空数据库时异步释放内存</li></ul></blockquote></li></ul><h3 id="redis过期key删除"><a href="#redis过期key删除" class="headerlink" title="redis过期key删除"></a>redis过期key删除</h3><p>默认情况下,  redis会每隔200毫秒删除一些过期key.  这个删除操作会阻塞主线程,  从4.0版本开始,  可以设置异步删除<br>删除算法如下:</p><ol><li>采样ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除.   ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP默认个数为20.</li><li>如果超过 25% 的key过期了，则重复删除的过程，直到过期 key的比例降至 25% 以下<br>如果对大量的key设置了相同的过期时间,   这个算法,  有可能导致一直阻塞主线程</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis集合统计模式</title>
    <link href="/2022/03/14/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/14/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis集合统计模式"><a href="#Redis集合统计模式" class="headerlink" title="Redis集合统计模式"></a>Redis集合统计模式</h1><blockquote><p>Redis集合类型常见的统计模式有四种,  分别是聚合统计, 排序统计,  二值状态统计,  基数统计</p></blockquote><h3 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h3><p>聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素<br>比较常见的例子是统计网站新增的用户数,   每天的留存用户数<br>使用一个集合记录所有登陆过的用户.  Set类型,  key值为:  user:id<br>对于每天登陆的用户,  也使用Set类型记录,  key值形式为:  user:id:20220314<br>新增用户:  SDIFFSTORE  user:new user:id:20220314 user:id<br>留存用户: SINTERSTORE user:id:rem user:id:20220314 user:id:20220313</p><h3 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h3><p>比较经典的例子是网站的评论数<br>redis中有序的数据结构有List,  Sort Set<br>使用List会导致相同位置上的元素发生变动<br>Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的<br>可以从评论时间的先后给每条评论设置一个权重值,  保存在Sort Set中</p><h3 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h3><p>这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。<br>比较经典的应用场景是打卡场景,  记录签到（1）或未签到（0）<br>Redis提供了一个扩展的数据类型Bitmap,  可以按照偏移值offset对bit数组的某一个 bit 位进行读和写.<br>记录签到:  setbit  key  offset 1<br>检测是否签到:  getbit key  offset<br>统计签到:  bitcount key </p><h3 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h3><p>基数统计就是指统计一个集合中不重复的元素个数<br>统计网页的UV时,  就需要用到基数统计<br>基数统计在Redis里可以使用Set或者Hash的数据结构<br>但数据很多时,  Set跟Hash会占用比较大的数据结构<br>HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小<br>每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数<br>HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>maven跟java版本不匹配</title>
    <link href="/2022/03/14/maven_java/"/>
    <url>/2022/03/14/maven_java/</url>
    
    <content type="html"><![CDATA[<h1 id="maven跟java版本不匹配"><a href="#maven跟java版本不匹配" class="headerlink" title="maven跟java版本不匹配"></a>maven跟java版本不匹配</h1><blockquote><p>周末上线服务的时候,   遇到了maven https问题.   查看服务器系统版本,  发现系统maven版本使用的是3.2.2版本.  老版本不支持https,  于是升级maven版本成3.6.3.  对项目进行手动编译(mvn clean compile),   发现报错信息:  Fatal error compiling: invalid target release: 1.8</p></blockquote><p>查看网上信息,   说的是服务使用的java 版本不对.   项目里指定了使用了1.8的JDK版本.<br>查看服务器上,  使用的是java1.7版本.<br>当时,  这台服务上也部署了其他进程,   当时也郁闷,   部门里统一使用的JDK版本都是1.8.<br>为啥其他服务就没有这个问题.<br>又由于当时着急部署服务,   没敢花太多时间追查问题,   就将服务器1.7的JDK升级成了1.8<br>后续部署服务就成功了</p><ul><li>事后想了想,  这样的操作比较危险,   就将这样的问题反馈给了部门负责人,  担心会影响到其他服务,  也将其他进程一一重启.    后续虽然没啥问题,  但现在回想起来还是有点蛮撞</li><li>后续也对项目进行了问题排查.   为啥其他进程部署没啥问题,   而这个服务部署却有问题</li></ul><p>查看项目, 项目里使用了maven-compiler-plugin插件<br>查看网上关于maven-compiler-plugin插件的详解.<br>maven是个项目管理工具,   如果不告诉代码要使用什么样的版本号,  会默认使用maven-compile-plugin插件指定的版本号.  项目里已经指定了JDK1.8的版本号</p><p>查看机器当时的maven使用的版本号为1.7,    使用了版本号对不上的问题.  这就是当时报错的问题</p><figure class="highlight dust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;java.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;java.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.build.sourceEncoding&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>         </span><br></code></pre></td></tr></table></figure><p>那为啥其他服务部署没有问题呢,   查看部署脚本.<br>发现部署脚本将jdk1.8配置进入环境变量.   maven编译打包的时候,   使用的是就是jdk1.8版本.<br>而自己手动编译项目时,  maven使用的是jdk1.7的版本.  这就是为啥手动编译出现了问题</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> <span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/jdk1.8.0_161<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$JAVA_HOME</span>/jre<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$JAVA_HOME</span>/bin:$PATH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis字符串数据结构</title>
    <link href="/2022/03/12/redis_string/"/>
    <url>/2022/03/12/redis_string/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis字符串数据结构"><a href="#Redis字符串数据结构" class="headerlink" title="Redis字符串数据结构"></a>Redis字符串数据结构</h1><blockquote><p>Redis字符串使用了RedisObject跟SDS的数据结构来保存数据. </p></blockquote><h3 id="Redis-key-value数据结构"><a href="#Redis-key-value数据结构" class="headerlink" title="Redis key_value数据结构"></a>Redis key_value数据结构</h3><p>Redis使用了全局哈希表来保存所有键值对.  哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对.<br>dictEntry 结构中有三个 8 字节的指针, 分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节.</p><img src="../redis_string/1.webp" width="55%" height="55%" /><p>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。</p><h3 id="Redis-SDS数据结构"><a href="#Redis-SDS数据结构" class="headerlink" title="Redis SDS数据结构"></a>Redis SDS数据结构</h3><p>当数据类型包含字符串时,   Redis会使用SDS数据结构来存储这些数据.<br>SDS数据结构有以下三个字段</p><ul><li>buf: 字节数据,  保存实际数据.  Redis会在最后数组最后加一个”\0””,  会占用一个字节</li><li>len: 表示buf已用长度,  占用四个字节</li><li>alloc: 占个 4 字节，表示 buf 的实际分配长度，一般大于 len</li></ul><img src="../redis_string/2.webp" width="55%" height="55%" /><h3 id="RedisObject数据结构"><a href="#RedisObject数据结构" class="headerlink" title="RedisObject数据结构"></a>RedisObject数据结构</h3><blockquote><p>Redis的数据类型很多,  不同的数据类型都有些元数据需要记录. Redis会使用RedisObject结构体来统一记录这些元数据,  同时指向实际数据</p></blockquote><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在.</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在.<br>元数据包括了 type、encoding、lru 和 refcount 4 个元数据</p><ul><li>type: 表示数据类型</li><li>encoding:  是值的编码方式，用来表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希表、跳表等；</li><li>lru: 记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对</li><li>refcount: 记录了对象的引用计数</li></ul><img src="../redis_string/3.webp" width="55%" height="55%" /><img src="../redis_string/5.webp" width="55%" height="55%" /><h3 id="RedisObject编码格式"><a href="#RedisObject编码格式" class="headerlink" title="RedisObject编码格式"></a>RedisObject编码格式</h3><ul><li>int编码.   保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数</li><li>embstr编码.  保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片</li><li>raw编码.  当字符串大于 44 字节时，SDS 的数据量就开始变多了.   会使用指针指向SDS结构</li></ul><img src="../redis_string/4.webp" width="55%" height="55%" />]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
