<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis集合统计模式</title>
    <link href="/2022/03/14/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/14/Redis%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis集合统计模式"><a href="#Redis集合统计模式" class="headerlink" title="Redis集合统计模式"></a>Redis集合统计模式</h1><blockquote><p>Redis集合类型常见的统计模式有四种,  分别是聚合统计, 排序统计,  二值状态统计,  基数统计</p></blockquote><h3 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h3><p>聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素<br>比较常见的例子是统计网站新增的用户数,   每天的留存用户数<br>使用一个集合记录所有登陆过的用户.  Set类型,  key值为:  user:id<br>对于每天登陆的用户,  也使用Set类型记录,  key值形式为:  user:id:20220314<br>新增用户:  SDIFFSTORE  user:new user:id:20220314 user:id<br>留存用户: SINTERSTORE user:id:rem user:id:20220314 user:id:20220313</p><h3 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h3><p>比较经典的例子是网站的评论数<br>redis中有序的数据结构有List,  Sort Set<br>使用List会导致相同位置上的元素发生变动<br>Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的<br>可以从评论时间的先后给每条评论设置一个权重值,  保存在Sort Set中</p><h3 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h3><p>这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。<br>比较经典的应用场景是打卡场景,  记录签到（1）或未签到（0）<br>Redis提供了一个扩展的数据类型Bitmap,  可以按照偏移值offset对bit数组的某一个 bit 位进行读和写.<br>记录签到:  setbit  key  offset 1<br>检测是否签到:  getbit key  offset<br>统计签到:  bitcount key </p><h3 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h3><p>基数统计就是指统计一个集合中不重复的元素个数<br>统计网页的UV时,  就需要用到基数统计<br>基数统计在Redis里可以使用Set或者Hash的数据结构<br>但数据很多时,  Set跟Hash会占用比较大的数据结构<br>HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小<br>每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数<br>HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>maven跟java版本不匹配</title>
    <link href="/2022/03/14/maven_java/"/>
    <url>/2022/03/14/maven_java/</url>
    
    <content type="html"><![CDATA[<h1 id="maven跟java版本不匹配"><a href="#maven跟java版本不匹配" class="headerlink" title="maven跟java版本不匹配"></a>maven跟java版本不匹配</h1><blockquote><p>周末上线服务的时候,   遇到了maven https问题.   查看服务器系统版本,  发现系统maven版本使用的是3.2.2版本.  老版本不支持https,  于是升级maven版本成3.6.3.  对项目进行手动编译(mvn clean compile),   发现报错信息:  Fatal error compiling: invalid target release: 1.8</p></blockquote><p>查看网上信息,   说的是服务使用的java 版本不对.   项目里指定了使用了1.8的JDK版本.<br>查看服务器上,  使用的是java1.7版本.<br>当时,  这台服务上也部署了其他进程,   当时也郁闷,   部门里统一使用的JDK版本都是1.8.<br>为啥其他服务就没有这个问题.<br>又由于当时着急部署服务,   没敢花太多时间追查问题,   就将服务器1.7的JDK升级成了1.8<br>后续部署服务就成功了</p><ul><li>事后想了想,  这样的操作比较危险,   就将这样的问题反馈给了部门负责人,  担心会影响到其他服务,  也将其他进程一一重启.    后续虽然没啥问题,  但现在回想起来还是有点蛮撞</li><li>后续也对项目进行了问题排查.   为啥其他进程部署没啥问题,   而这个服务部署却有问题</li></ul><p>查看项目, 项目里使用了maven-compiler-plugin插件<br>查看网上关于maven-compiler-plugin插件的详解.<br>maven是个项目管理工具,   如果不告诉代码要使用什么样的版本号,  会默认使用maven-compile-plugin插件指定的版本号.  项目里已经指定了JDK1.8的版本号</p><p>查看机器当时的maven使用的版本号为1.7,    使用了版本号对不上的问题.  这就是当时报错的问题</p><figure class="highlight dust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;java.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;java.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.build.sourceEncoding&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>         </span><br></code></pre></td></tr></table></figure><p>那为啥其他服务部署没有问题呢,   查看部署脚本.<br>发现部署脚本将jdk1.8配置进入环境变量.   maven编译打包的时候,   使用的是就是jdk1.8版本.<br>而自己手动编译项目时,  maven使用的是jdk1.7的版本.  这就是为啥手动编译出现了问题</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> <span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/jdk1.8.0_161<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$JAVA_HOME</span>/jre<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$JAVA_HOME</span>/bin:$PATH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis字符串数据结构</title>
    <link href="/2022/03/12/redis_string/"/>
    <url>/2022/03/12/redis_string/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis字符串数据结构"><a href="#Redis字符串数据结构" class="headerlink" title="Redis字符串数据结构"></a>Redis字符串数据结构</h1><blockquote><p>Redis字符串使用了RedisObject跟SDS的数据结构来保存数据. </p></blockquote><h3 id="Redis-key-value数据结构"><a href="#Redis-key-value数据结构" class="headerlink" title="Redis key_value数据结构"></a>Redis key_value数据结构</h3><p>Redis使用了全局哈希表来保存所有键值对.  哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对.<br>dictEntry 结构中有三个 8 字节的指针, 分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节.</p><img src="../redis_string/1.webp" width="55%" height="55%" /><p>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。</p><h3 id="Redis-SDS数据结构"><a href="#Redis-SDS数据结构" class="headerlink" title="Redis SDS数据结构"></a>Redis SDS数据结构</h3><p>当数据类型包含字符串时,   Redis会使用SDS数据结构来存储这些数据.<br>SDS数据结构有以下三个字段</p><ul><li>buf: 字节数据,  保存实际数据.  Redis会在最后数组最后加一个”\0””,  会占用一个字节</li><li>len: 表示buf已用长度,  占用四个字节</li><li>alloc: 占个 4 字节，表示 buf 的实际分配长度，一般大于 len</li></ul><img src="../redis_string/2.webp" width="55%" height="55%" /><h3 id="RedisObject数据结构"><a href="#RedisObject数据结构" class="headerlink" title="RedisObject数据结构"></a>RedisObject数据结构</h3><blockquote><p>Redis的数据类型很多,  不同的数据类型都有些元数据需要记录. Redis会使用RedisObject结构体来统一记录这些元数据,  同时指向实际数据</p></blockquote><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在.</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在.<br>元数据包括了 type、encoding、lru 和 refcount 4 个元数据</p><ul><li>type: 表示数据类型</li><li>encoding:  是值的编码方式，用来表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希表、跳表等；</li><li>lru: 记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对</li><li>refcount: 记录了对象的引用计数</li></ul><img src="../redis_string/3.webp" width="55%" height="55%" /><img src="../redis_string/5.webp" width="55%" height="55%" /><h3 id="RedisObject编码格式"><a href="#RedisObject编码格式" class="headerlink" title="RedisObject编码格式"></a>RedisObject编码格式</h3><ul><li>int编码.   保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数</li><li>embstr编码.  保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片</li><li>raw编码.  当字符串大于 44 字节时，SDS 的数据量就开始变多了.   会使用指针指向SDS结构</li></ul><img src="../redis_string/4.webp" width="55%" height="55%" />]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
